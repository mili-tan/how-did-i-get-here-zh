## 幕后故事

为了访问这个网站，你的电脑通过互联网发送了一些数据包。如果我们好奇这些数据包走过的路径是什么样的，我们可以运行一个工具来生成 *traceroute*（路由追踪） —— 一个粗略的、列出了你的数据包到达目的地所经过的每个服务器的列表。为了构建这个网站 ([GitHub 上的源代码](https://github.com/hackclub/how-did-i-get-here))，我写了一个自己的 traceroute 程序，叫做 ktr ([它同样是开源的](https://github.com/kognise/ktr))，它可以实时流式传输结果，同时并发地查找关于每一跳节点的有趣信息。

ktr 是如何工作的？让我们从解释一个简化的互联网路由开始。

从源设备开始，处理数据包的每一台计算机都必须选择将其转发到的最佳设备 —— 我稍后会解释这些路由决策是如何做出的。假设一切工作正常，数据包最终会到达一个知道如何将其直接发送到目的地的路由。

我的 traceroute 实现采用了一种叫做 [ICMP](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol) 的协议，ICMP 是专门为在互联网上发送诊断信息而设计的。（_译者注：大名鼎鼎的 Ping 同样使用的也是 ICMP 喔！_）而且，很有用的是，几乎每台联网的设备都支持它。更有趣的是，ICMP 数据包有一个“TTL”（生存时间）字段。这实际上并不像它的名字所暗示的那样是一个“时间” —— 实际上它是一个倒计时！每次路由转发一个 ICMP 数据包时，它都应该减少 TTL 数值。当 TTL 降为零时，路由应该停止转发它，而是向数据包的源 IP 发送一条错误消息，说明数据包已达到其最大跳数。

我们就可以利用这个 TTL 特性！要进行一次 traceroute，我们可以发送一系列 TTL 逐渐增大的 ICMP 数据包。第一个 TTL 为 1 的数据包将在它到达的第一个设备上就出错，以此类推，直到我们有希望从处理过该数据包的每个路由设备那里都收到一个错误。这些错误的数据包就包含了诊断信息，比如发送错误的设备的 IP 地址，这从而使我们能够追踪你的数据包在互联网上的大致路径。

### 前端趣闻

这个页面在禁用 JavaScript 的情况下也能完美工作。从浏览器的角度来看，这个网站只是加载得有点慢。而从你的角度来看，一个 traceroute 神奇地加载了进来。

当你加载这个网站时，我的程序收到了一个来自你的 IP 地址的 HTTP 请求。它立即开始向你的 IP 运行一个 traceroute。然后，服务器开始响应 HTTP 请求：它发送了这个网页的开头部分，然后保持连接打开。当我的 traceroute 程序 ktr 向服务器更新你的 traceroute 进度时，服务器会渲染相关的 HTML 并将其发送到你的电脑。当 traceroute 完成时，服务器生成了所有文本，并在关闭连接之前将网站的其余部分发送出去。

你可能已经注意到，traceroute 是一行行地从底部向上逐步加载的。网页只能向前加载。由于我不想使用任何 JavaScript，我做了最取巧的事情：每次我更新 traceroute 显示时，我都会嵌入一个 CSS 代码块来隐藏之前的版本！由于浏览器在页面加载时会渲染 CSS，这使得 traceroute 看起来像是在随时间推移而被编辑。

### 从前到后，再从后到前

我声称这个网站的 traceroute 是你的数据包到达我的服务器所经过的路径，但是这其实是个善意的谎言。要计算出那条路径，我必须能够*从你的电脑*向我的服务器运行一个 traceroute。相反，我从我的服务器向你的电脑运行了 traceroute，然后只是把它反转了过来。这也是为什么顶部的 traceroute 看起来是以相反的顺序加载的。

运行“反向 traceroute”会牺牲准确性吗？确实会牺牲一点点。（_译者注：如果你常关注 VPS 或线路，你一定听过“去程路由”和“回程路由”。从服务器到你的电脑这就是“回程路由”了。_）


正如我在描述互联网路由时所说，数据包经过的每个设备都会决定下一步将数据包发送到哪里，直到到达最终目的地。如果你朝另一个方向发送一个数据包，这些设备可能会做出不同的路由决策……而如果一个设备做了一个不同的决策，其余的路径肯定会不同。

（_译者注：由于成本、负载、路由调整，BGP去程与回程路径不同其实是一种常见且完全正常的情况，这也被称为 “非对称路由”_）

这个反向 traceroute 仍然是有帮助的。路径大致是相同的，可能只在你的数据包经过了哪些特定路由方面有所不同。

### 那么，所有这些网络是什么？

这个网站一开始就谈论了你为了到达我的服务器所穿越的“网络”。具体来说，这些网络是什么呢？

每个网络，也称为自治系统（AS），是一组相互私有连接的路由和服务器，通常由同一家公司拥有。这些自治系统的所有者通过选择与其他哪些自治系统连接来决定互联网的形态。互联网流量在彼此之间有“对等互联（peering arrangements）”的自治系统之间传输。

互联网通常被描述为一个开放的、近乎无政府状态的连接计算机的网络，其中一些计算机由像你和我这样的人拥有，一些由公司拥有。但是实际上，互联网其实是一个主要由公司拥有的网络组成的网络，对其的访问和控制由金融交易支配，并且充斥着官僚主义作风。

当然，如果你想要自己的自治系统，你可以向管理互联网编号的五个[区域互联网注册管理机构（RIR）](https://en.wikipedia.org/wiki/Regional_Internet_registry)之一申请一个自治系统号码（ASN）。但要也提醒你，或者你在互联网上没有足够多的接入点（points of presence），他们可能不会理你。（_译者注：其实也还需要一笔不太小的资金，以 APNIC 为例直接申请 ASN 的前置条件会员费（还不包括其他费用），截至 2025 年为 1,236 AUD。但是其实你可以通过[Sponsor申请](https://twd2.me/archives/11591)。_）

就像我们使用 IP 地址来识别——

*等等，那么 IP 地址到底识别的是什么？呃……我们姑且说它们代表可以访问互联网的设备吧。*

……就像我们使用 [IP 地址](https://en.wikipedia.org/wiki/IP_address)来识别可以访问互联网的设备一样，我们使用 ASN 来识别互联网的网络。<% if (tracerouteInfo.hopAsnStrings[0]) { %><span class='generated'>这些就是 traceroute 开头那些像“<%= tracerouteInfo.hopAsnStrings[0] %>”的数字。</span><% } %>

### 关于 WHOIS

我自己编写一个很酷的 traceroute 程序的原因之一，是让我能够获取你的 traceroute 路径上 IP 所属自治系统的信息。有几个组织试图跟踪哪些 AS 包含哪些 IP 地址。它们中的许多允许你使用 [WHOIS 协议](https://en.wikipedia.org/wiki/WHOIS) 执行 ASN 查询，所以我写了一个小客户端来解析我随意选择的一些服务器的响应。

然后我使用了一个叫做 [PeeringDB](https://www.peeringdb.com/) 的很酷的开放数据库来找出 ASN 背后的公司；PeeringDB 拥有大约三分之一自治系统的信息。我使用了所有这些信息，外加几百行 if 语句，为你生成了关于网络穿越的文本。

WHOIS 实际上是一个……为它编写解析器很有趣的协议。事实证明，[WHOIS 协议规范](https://datatracker.ietf.org/doc/html/rfc3912/) 实际上规定得很少。它规定你应该与 WHOIS 服务器建立 TCP 连接，发送任何你想要查询的内容，然后服务器会发回一些信息并终止连接。就这样。

然而，很多 WHOIS 服务器会用看起来结构化的信息来响应：

<img src='/whois-screenshot.png' width='942' height='716' alt='终端应用程序的截图。运行的命令是：whois 198.58.104.130。结果是结构化的文本，以百分号和文本“IANA WHOIS server.”开头'>

事实证明，这种结构是由 WHOIS 服务器管理员编造的，而且服务器之间恰好有一些共同的惯例。即使有这种结构程度，你想要的字段也经常以不同的名称（origin? originas?）出现，甚至同时在多个地方出现。

我的"解析器"最终并不像一个解析器，而更像是一个轻量级的模拟器，模拟我作为一个人类，如何浏览 WHOIS 结果来找到我需要的 ASN。

## BGP

当你通过互联网发送一个数据包时，位于这些网络连接边界处的路由器会决定下一步将你的数据包发送到哪个网络，直到它到达包含目标设备的网络。

这些边界路由器使用一种称为边界网关协议（BGP）的协议相互通信，告知对方它们能够连接到哪些网络。

BGP 是赋予互联网形态的协议，而且你[不能直接自己使用它](https://jvns.ca/blog/2021/10/05/tools-to-look-at-bgp-routes/)。

### 历史故事时间

1969年，同年尼尔·阿姆斯特朗登上了月球，一条消息在 ARPANET 的原型上被（部分）发送。在接下来的 20 年里，这种"互联计算机网络"的东西变得非常流行，每个人都想搭上这班车。各个大学、政府机构以及一些的零星公司开始纷纷创建自己的计算机网络。

其中一些组织开始将他们的网络连接在一起，以便更轻松地共享数据。我们所熟知的互联网那时还不存在，但这些网络互连就已经开始变得难以管理，并且没有一个很好的标准来协调它们。1989 年，思科和 IBM 的工程师发布了 [RFC 1105](https://datatracker.ietf.org/doc/html/rfc1105/)，描述了第一个版本的 BGP。

在接下来的几年里，那些搞互联的人们变得非常忙碌，因为"互联网"迅速成为一个现实。就在 BGP v1 RFC 发布一年后，思科上市并为网络行业带来了大量资金，“IANA”一词首次被用来指代那个[负责管理互联网编号的某位人士](https://en.wikipedia.org/wiki/Jon_Postel)和他的大学部门，ARPANET 永久关闭，并且 [BGP v2](https://datatracker.ietf.org/doc/html/rfc1163) 发布了。

1994 年，就在“互联网已成现实”的旋风刚刚开始平息之际，BGP 的最终主要版本 v4 在 [RFC 1654](https://datatracker.ietf.org/doc/html/rfc1654) 中被规定。它经历了两次修订（在 [1995 年](https://datatracker.ietf.org/doc/html/rfc1771) 和 [2006 年](https://datatracker.ietf.org/doc/html/rfc4271)）并得到了一些补丁，但 BGP v4 仍然是我们用来在构成现代互联网的互联网络中选择路由的协议。

### BGP 这玩意到底是怎么工作的？

自治系统之间边界上的路由（“边界网关”）保存着它们所知道的每个 *BGP 路由* 的列表，称为 *路由表*。每个 BGP 路由指定了可以遵循的 ASN 路径，沿着这条路径可以到达控制着特定 IP 地址集合的自治系统。

这些跨越互联网的路由是通过自治系统之间的*对等关系*形成的。当两个自治系统的边界网关*对等*时，他们通常同意：

1.  允许流量在两个路由之间传输，这意味着 BGP 路由可以直接在两个 ASN 之间传递。
2.  互相更新他们知道的 BGP 路由。

例子时间！AS0001 的路由 A 与 AS0002 的路由 B 物理连接，并且他们想要彼此对等。他们互相发送 BGP 消息来建立一个 *BGP 会话*。路由 A 现在知道，对于任何以 AS0002 开头的 BGP 路由，它都应该通过路由 B，反之亦然。

<img src='/networks-example.svg' width='380' height='308' style='max-width: 460px; margin: 40px auto;' alt='3个网络的示意图。AS0001 连接到 AS0002，而 AS0002 又连接到 AS1234。'>

BGP 对等体通过一个称为*路由通告*的过程相互分享他们知道的路由。在我们上面的例子中，当路由 A 连接到路由 B 时，它会告诉路由 B “嘿，这是我所有知道的路由，你可以通过我的 ASN（进而通过我）到达所有这些路由。” 路由 B 将所有那些通过路由 A 的路由——也就是以 AS0001 开头的路由——添加到它的路由表中。每当路由 A 的另一个对等体通告一条新路由时，路由 A 会将这些路由转发通告给路由 B。

AS0001 可能自己直接控制一些 IP 地址。路由 A 也会将这些路由通告给路由 B。然后路由 B 会依次将这些直接路由向前通告，告诉*它的*对等体们 AS0002 → AS0001 是到达那些 IP 的有效路由。通过这种将路由通告转发给对等体的过程，BGP 路由在整个自治系统网络中传播开来，使得任何边界网关都有希望知道一条或多条 AS 路径来到达互联网上的任何 IP。

要将一个数据包路由到某个 IP，边界网关首先在其路由表中搜索每一条能将其带到一个控制该 IP 的 AS 的路由。然后路由通过[各种启发式方法](https://en.wikipedia.org/wiki/Border_Gateway_Protocol#Route_selection_process)选择“最佳”路由，这些方法包括寻找最短路径和权衡对某些自治系统的硬编码的偏好。最后，它通过将数据包发送给该路径中第一个 AS 的网关路由（它与该路由是对等的）来路由该数据包。那个路由接着查看自己的路由表，并且自己决定下一步将数据包发送到哪里。

<% if (tracerouteInfo.connection) { %>
### 回顾 Traceroute

<div class='generated'>

在开头的 traceroute 中，你的数据包最终采用的 AS 路径是 <%= tracerouteInfo.hopAsnStrings.join(' → ') %>。这意味着，例如，在某个时刻，你的数据包到达了 <%= tracerouteInfo.connection[0] %> 的一个路由，该路由与 <%= tracerouteInfo.connection[1] %> 的一个路由对等，该路由查看其路由表，发现目的 IP 可以通过某个以 <%= tracerouteInfo.connection[1] %> 开头的路由到达，于是将你的数据包转发给了那个连接的路由。

<% if (tracerouteInfo.showHighestFrequencyNetwork) { %>
在同一个 ASN 内有几跳；看看有 <%= tracerouteInfo.highestFrequencyNetworkCount %> 跳经过了 <%= tracerouteInfo.highestFrequencyNetworkName %>。Traceroute 确实向我们展示了你的数据包经过的*每一个*路由，而不仅仅是那些位于自治系统边界的路由。如果路由知道其内部网络中存在一条高效路径，它们通常会用它来覆盖外部的 BGP 路由。这些内部路径可能是通过内部版本的 BGP、另一种内部路由协议学到的，或者干脆就是硬编码的。

这些内部跳数对于理解互联网如何运作并不十分重要。只有不同自治系统之间的对等互联才决定可达性。
<% } %>

</div>
<% } %>

## 回顾整体

- 当你加载这个网站时，它使用我的自定义 traceroute 程序向你的公网 IP (<span class='generated'><%= pageGlobals.userIp %></span>) 运行了一个 traceroute，通过 HTTP 流式传输该过程，然后渲染出 traceroute 的文本解释。

- Traceroute 描绘了互联网上两个设备之间穿越的路由路径。我的特定实现是通过发送 TTL 字段递增的 ICMP 数据包来工作的。

- 这些路由位于称为自治系统的网络中。这些 AS 边缘的路由使用 BGP 相互对等。边界路由使用 BGP 相互共享它们的路由表，然后利用这些信息做出路由决策。

- BGP 对等会话是根据自治系统所有者之间（通常是私下的）互联建立的。由于流量只能在相互对等的网络之间传递，这些互联是互联网上可达性的唯一管理者。

## 尾声

我曾对当前人们对互联网结构的理解状况感到沮丧，并试图写一篇全面的、互动的文章，通过协议的视角来涵盖其历史和政治。然而，我被生活中的许多复杂性所困，面对紧迫的截止日期，没有时间实现我为自己设定的崇高目标。

感谢我在 Hack Club 的朋友们的鼓励，我充分利用了我所拥有的一切。“造个小筏子出海，也比永远造不出的游艇强！” 如果没什么别的好处，我至少用上了那个超牛的 traceroute 程序，它也为这个网站最闪亮的部分提供了动力 :)

我希望这能成为网络上另一个有趣、信息丰富且制作精良的东西，能够持续存在，被分享传播，并激励人们。

以致爱意，  
Lexi

### 其他东西

一些也可以看看的东西：

- [我过去写的东西](https://kognise.dev/writing)
- [Hack Club，如果你是年轻人，这里是最好的社区](https://hackclub.com/)

自豪地开源：

- [这个网站的源代码](https://github.com/hackclub/how-did-i-get-here)
- [我的 traceroute 程序的源代码](https://github.com/kognise/ktr)
- [本网站所有艺术的公开 Figma 文件](https://www.figma.com/community/file/1260699047973407903/article-diagrams)
